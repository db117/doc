---
title: java的修饰符
---

## 权限修饰符
*   public  
    *   使用对象：最广，类、接口、变量、方法
*   protected
    *   使用对象：变量、方法 注意：不能修饰类（外部类）
*   default
    *   使用对象：类、接口、变量、方法。（即缺省，什么也不写）
*   private
    *   使用对象：变量、方法 注意：不能修饰类（外部类）

## 修饰符
*   abstract
    *   使用对象：类、接口、方法
*   static
    *   使用对象：类、变量、方法、初始化函数（注意：**修饰类时只能修饰内部类**）
*   final
    *   使用对象：类、变量、方法
*   transient
    *   告诉编译器，在类对象序列化的时候，此变量不需要持久保存
*   volatile
    *   指出可能有多个线程修改此变量，要求编译器优化以保证对此变量的修改
        能够被正确的处理
*   native
    *   用该修饰符定义的方法在类中没有实现，而大多数情况下该方法的实现
        是用C、C++编写的。
*   synchronized
    *   修饰方法，多线程的支持

## 外部类和内部类
*   外部类是相对于内部类而言的，内部类是定义在类里面的类。

## 外部类的修饰符

*   default（缺省，不写）
    *   类定义时前面未加任何修饰符，表示同一个包中可见。

*   public
    *   修饰类时表示该类能被项目中所有类可见

*   abstract
    *   表示是抽象类

*   final
    *  表示类不可以被继承

*   scrictpf
    *   (java关键字) 当对一个类或接口使用 strictfp 关键字时，
    该类中的所有代码，包括嵌套类型中的初始设定值和代码，
    都将严格地进行计算。严格约束意味着所有表达式的结果都必须是 
    IEEE 754 算法对操作数预期的结果，以单精度和双精度格式表示

## 内部类

*   成员内部类
    *   作为外部类的一个成员存在，与外部类的属性、方法并列
    *   成员内部类修饰符有：
        *   public：
        *   protected：
        *   private：private不能修饰外部类，
        *   abstract：
        *   final：
        *   static：可以当做普通类使用，而不用先实例化一个外部类。（用他修饰后，就成了静态内部类了）
        *   strictfp：（java关键字） 即 strict float point (精确浮点)。（可修饰类、接口、方法）

*   局部内部类
    *   局部内部类就是在类内的方法中定义的类。
    *   局部类有一个优势，即对外部世界完全隐藏。即使是同一个类中其他的方法也不能访问它。
    *   局部类可以访问包含它的外部类，同时也可以访问局部变量。
    *   局部类不能用public或private访问说明符进行声明，他的作用域被限定在这个方法中，

*   静态内部类
    *   使用static修饰的内部类

*   匿名内部类
    *   就是没有名字的内部类


## 访问权限符与继承

*   这里的访问权限修饰符指的是：修饰成员变量和方法。分两种情况：
    *   子类与父类在同一个包中
        *   此时只有private修饰的变量和方法不能被访问。

    *   子类与父类不在同一个包中
        *   此时private和default均不能被访问，protected和public可以

## 接口修饰符

*   public：所有包可见

*   default：（缺省）同一个包中可见

*   strictfp:（java关键字） 即 strict float point (精确浮点)。

*   接口的变量总是需要定义成：public static final 类型 名称，但可以不用写的这么复杂，默认就是public static final

*   接口的方法只能使用public、abstract修饰。